interface Prelude where {
infixr  9 .;
infixr  0 $!;
infixr  0 $;
infixr  1 =<<;
infixr  8 ^^;
infixr  8 ^;
infixr  2 ||;
infixr  3 &&;
infix   4 `notElem`;
infixl  9 !!;
infix   4 `elem`;
infixr  5 ++;
infixl  7 Data.Ratio.%;
infixr  8 **;
infixl  7 /;
infixl  7 `quot`;
infixl  7 `rem`;
infixl  7 `div`;
infixl  7 `mod`;
prefix negate 6 -;
infixl  6 +;
infixl  7 *;
infixl  1 >>;
infixl  1 >>=;
infix   4 <=;
infix   4 <;
infix   4 >=;
infix   4 >;
infixr  5 :;
infix   4 /=;
infix   4 ==;

{-# NEED #-}
instance Ix @ Ix.Ix Bool;

{-# NEED #-}
instance Ix @ Ix.Ix Int;

{-# NEED #-}
instance Ix @ Ix.Ix Integer;

{-# NEED #-}
instance Ix @ (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d) => Ix.Ix (a,b,c,d);

{-# NEED #-}
instance Ix @ (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e) => Ix.Ix (a,b,c,d,e);

{-# NEED #-}
instance Ix @ (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f) => Ix.Ix (a,b,c,d,e,f);

{-# NEED #-}
instance Ix @ (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g) => Ix.Ix (a,b,c,d,e,f,g);

{-# NEED #-}
instance Ix @ (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g,Ix.Ix h) => Ix.Ix (a,b,c,d,e,f,g,h);

{-# NEED #-}
instance Ix @ (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g,Ix.Ix h,Ix.Ix i) => Ix.Ix (a,b,c,d,e,f,g,h,i);

{-# NEED #-}
instance Ix @ (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g,Ix.Ix h,Ix.Ix i,Ix.Ix j) => Ix.Ix (a,b,c,d,e,f,g,h,i,j);

{-# NEED #-}
instance Ix @ (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g,Ix.Ix h,Ix.Ix i,Ix.Ix j,Ix.Ix k) => Ix.Ix (a,b,c,d,e,f,g,h,i,j,k);

{-# NEED #-}
instance Ix @ (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g,Ix.Ix h,Ix.Ix i,Ix.Ix j,Ix.Ix k,Ix.Ix l) => Ix.Ix (a,b,c,d,e,f,g,h,i,j,k,l);

{-# NEED #-}
instance Ix @ (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g,Ix.Ix h,Ix.Ix i,Ix.Ix j,Ix.Ix k,Ix.Ix l,Ix.Ix m) => Ix.Ix (a,b,c,d,e,f,g,h,i,j,k,l,m);

{-# NEED #-}
instance Ix @ (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g,Ix.Ix h,Ix.Ix i,Ix.Ix j,Ix.Ix k,Ix.Ix l,Ix.Ix m,Ix.Ix n) => Ix.Ix (a,b,c,d,e,f,g,h,i,j,k,l,m,n);

{-# NEED #-}
instance Ix @ (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g,Ix.Ix h,Ix.Ix i,Ix.Ix j,Ix.Ix k,Ix.Ix l,Ix.Ix m,Ix.Ix n,Ix.Ix o) => Ix.Ix (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o);

{-# NEED #-}
instance Ix @ (Ix.Ix a,Ix.Ix b,Ix.Ix c) => Ix.Ix (a,b,c);

{-# NEED #-}
instance Prelude @ Ix.Ix Ordering;

{-# NEED #-}
instance Ix @ (Ix.Ix a,Ix.Ix b) => Ix.Ix (a,b);

{-# NEED #-}
instance Ix @ Ix.Ix Char;

{-# NEED #-}
instance Prelude @ Ix.Ix ();

{-# NEED #-}
instance Foreign.Storable @ Foreign.Storable.Storable Float;

{-# NEED #-}
instance Foreign.Storable @ Foreign.Storable.Storable Double;

{-# NEED #-}
instance Foreign.Storable @ Foreign.Storable.Storable Bool;

{-# NEED #-}
instance Foreign.Storable @ Foreign.Storable.Storable Int;

{-# NEED #-}
instance Foreign.Storable @ Foreign.Storable.Storable Char;

{-# NEED #-}
instance Prelude @ Floating Float;

{-# NEED #-}
instance Prelude @ Floating Double;

{-# NEED #-}
instance Prelude @ Fractional Float;

{-# NEED #-}
instance Prelude @ Fractional Double;

{-# NEED #-}
instance Prelude @ Num Float;

{-# NEED #-}
instance Prelude @ Num Double;

{-# NEED #-}
instance Prelude @ Num Int;

{-# NEED #-}
instance Prelude @ Num Integer;

{-# NEED #-}
instance Prelude @ RealFrac Float;

{-# NEED #-}
instance Prelude @ RealFrac Double;

{-# NEED #-}
instance Prelude @ RealFloat Float;

{-# NEED #-}
instance Prelude @ RealFloat Double;

{-# NEED #-}
instance Prelude @ Real Float;

{-# NEED #-}
instance Prelude @ Real Double;

{-# NEED #-}
instance Prelude @ Real Int;

{-# NEED #-}
instance Prelude @ Real Integer;

{-# NEED #-}
instance Prelude @ Integral Int;

{-# NEED #-}
instance Prelude @ Integral Integer;

{-# NEED #-}
instance Prelude @ Monad [];

{-# NEED #-}
instance Prelude @ Monad Maybe;

{-# NEED #-}
instance Prelude @ Monad YHC.Internal.IO;

{-# NEED #-}
instance Prelude @ Bounded Int;

{-# NEED #-}
instance Prelude @ Bounded Bool;

{-# NEED #-}
instance Prelude @ (Bounded a,Bounded b,Bounded c) => Bounded (a,b,c);

{-# NEED #-}
instance Prelude @ (Bounded a,Bounded b) => Bounded (a,b);

{-# NEED #-}
instance Prelude @ Read Float;

{-# NEED #-}
instance Prelude @ Read Double;

{-# NEED #-}
instance Prelude @ Read Bool;

{-# NEED #-}
instance Prelude @ Read Int;

{-# NEED #-}
instance Prelude @ Read Integer;

{-# NEED #-}
instance Prelude @ (Read a,Read b,Read c,Read d) => Read (a,b,c,d);

{-# NEED #-}
instance Prelude @ (Read a,Read b,Read c,Read d,Read e) => Read (a,b,c,d,e);

{-# NEED #-}
instance Prelude @ (Read a,Read b,Read c,Read d,Read e,Read f) => Read (a,b,c,d,e,f);

{-# NEED #-}
instance Prelude @ (Read a,Read b,Read c,Read d,Read e,Read f,Read g) => Read (a,b,c,d,e,f,g);

{-# NEED #-}
instance Prelude @ (Read a,Read b,Read c,Read d,Read e,Read f,Read g,Read h) => Read (a,b,c,d,e,f,g,h);

{-# NEED #-}
instance Prelude @ (Read a,Read b,Read c,Read d,Read e,Read f,Read g,Read h,Read i) => Read (a,b,c,d,e,f,g,h,i);

{-# NEED #-}
instance Prelude @ (Read a,Read b,Read c,Read d,Read e,Read f,Read g,Read h,Read i,Read j) => Read (a,b,c,d,e,f,g,h,i,j);

{-# NEED #-}
instance Prelude @ (Read a,Read b,Read c,Read d,Read e,Read f,Read g,Read h,Read i,Read j,Read k) => Read (a,b,c,d,e,f,g,h,i,j,k);

{-# NEED #-}
instance Prelude @ (Read a,Read b,Read c,Read d,Read e,Read f,Read g,Read h,Read i,Read j,Read k,Read l) => Read (a,b,c,d,e,f,g,h,i,j,k,l);

{-# NEED #-}
instance Prelude @ (Read a,Read b,Read c,Read d,Read e,Read f,Read g,Read h,Read i,Read j,Read k,Read l,Read m) => Read (a,b,c,d,e,f,g,h,i,j,k,l,m);

{-# NEED #-}
instance Prelude @ (Read a,Read b,Read c,Read d,Read e,Read f,Read g,Read h,Read i,Read j,Read k,Read l,Read m,Read n) => Read (a,b,c,d,e,f,g,h,i,j,k,l,m,n);

{-# NEED #-}
instance Prelude @ (Read a,Read b,Read c,Read d,Read e,Read f,Read g,Read h,Read i,Read j,Read k,Read l,Read m,Read n,Read o) => Read (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o);

{-# NEED #-}
instance Prelude @ (Read a,Read b,Read c) => Read (a,b,c);

{-# NEED #-}
instance Prelude @ Read Ordering;

{-# NEED #-}
instance Prelude @ (Read a,Read b) => Read (a,b);

{-# NEED #-}
instance Prelude @ (Read a,Read b) => Read (Either a b);

{-# NEED #-}
instance Prelude @ (Read a) => Read [a];

{-# NEED #-}
instance Prelude @ (Read a) => Read (Maybe a);

{-# NEED #-}
instance Prelude @ Read Char;

{-# NEED #-}
instance Prelude @ Read ();

{-# NEED #-}
instance Prelude @ Enum Float;

{-# NEED #-}
instance Prelude @ Enum Double;

{-# NEED #-}
instance Prelude @ Enum Bool;

{-# NEED #-}
instance Prelude @ Enum Int;

{-# NEED #-}
instance Prelude @ Enum Integer;

{-# NEED #-}
instance Prelude @ Enum Ordering;

{-# NEED #-}
instance Prelude @ Enum Char;

{-# NEED #-}
instance Prelude @ Show Float;

{-# NEED #-}
instance Prelude @ Show Double;

{-# NEED #-}
instance Prelude @ Show Bool;

{-# NEED #-}
instance Prelude @ Show Int;

{-# NEED #-}
instance Prelude @ Show Integer;

{-# NEED #-}
instance Prelude @ (Show a,Show b,Show c,Show d) => Show (a,b,c,d);

{-# NEED #-}
instance Prelude @ (Show a,Show b,Show c,Show d,Show e) => Show (a,b,c,d,e);

{-# NEED #-}
instance Prelude @ (Show a,Show b,Show c,Show d,Show e,Show f) => Show (a,b,c,d,e,f);

{-# NEED #-}
instance Prelude @ (Show a,Show b,Show c,Show d,Show e,Show f,Show g) => Show (a,b,c,d,e,f,g);

{-# NEED #-}
instance Prelude @ (Show a,Show b,Show c,Show d,Show e,Show f,Show g,Show h) => Show (a,b,c,d,e,f,g,h);

{-# NEED #-}
instance Prelude @ (Show a,Show b,Show c,Show d,Show e,Show f,Show g,Show h,Show i) => Show (a,b,c,d,e,f,g,h,i);

{-# NEED #-}
instance Prelude @ (Show a,Show b,Show c,Show d,Show e,Show f,Show g,Show h,Show i,Show j) => Show (a,b,c,d,e,f,g,h,i,j);

{-# NEED #-}
instance Prelude @ (Show a,Show b,Show c,Show d,Show e,Show f,Show g,Show h,Show i,Show j,Show k) => Show (a,b,c,d,e,f,g,h,i,j,k);

{-# NEED #-}
instance Prelude @ (Show a,Show b,Show c,Show d,Show e,Show f,Show g,Show h,Show i,Show j,Show k,Show l) => Show (a,b,c,d,e,f,g,h,i,j,k,l);

{-# NEED #-}
instance Prelude @ (Show a,Show b,Show c,Show d,Show e,Show f,Show g,Show h,Show i,Show j,Show k,Show l,Show m) => Show (a,b,c,d,e,f,g,h,i,j,k,l,m);

{-# NEED #-}
instance Prelude @ (Show a,Show b,Show c,Show d,Show e,Show f,Show g,Show h,Show i,Show j,Show k,Show l,Show m,Show n) => Show (a,b,c,d,e,f,g,h,i,j,k,l,m,n);

{-# NEED #-}
instance Prelude @ (Show a,Show b,Show c,Show d,Show e,Show f,Show g,Show h,Show i,Show j,Show k,Show l,Show m,Show n,Show o) => Show (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o);

{-# NEED #-}
instance Prelude @ (Show a,Show b,Show c) => Show (a,b,c);

{-# NEED #-}
instance Prelude @ Show Ordering;

{-# NEED #-}
instance Prelude @ (Show a,Show b) => Show (a,b);

{-# NEED #-}
instance Prelude @ Show IOError;

{-# NEED #-}
instance Prelude @ (Show a,Show b) => Show (Either a b);

{-# NEED #-}
instance Prelude @ (Show a) => Show [a];

{-# NEED #-}
instance Prelude @ (Show a) => Show (Maybe a);

{-# NEED #-}
instance Prelude @ Show Char;

{-# NEED #-}
instance Prelude @ Show ();

{-# NEED #-}
instance Prelude @ (Show a) => Show (YHC.Internal.IO a);

{-# NEED #-}
instance Prelude @ (Show a,Show b) => Show (a -> b);

{-# NEED #-}
instance Data.Ix @ Data.Ix.Ix Bool;

{-# NEED #-}
instance Data.Ix @ Data.Ix.Ix Int;

{-# NEED #-}
instance Data.Ix @ Data.Ix.Ix Integer;

{-# NEED #-}
instance Data.Ix @ (Data.Ix.Ix a,Data.Ix.Ix b,Data.Ix.Ix c,Data.Ix.Ix d) => Data.Ix.Ix (a,b,c,d);

{-# NEED #-}
instance Data.Ix @ (Data.Ix.Ix a,Data.Ix.Ix b,Data.Ix.Ix c,Data.Ix.Ix d,Data.Ix.Ix e) => Data.Ix.Ix (a,b,c,d,e);

{-# NEED #-}
instance Data.Ix @ (Data.Ix.Ix a,Data.Ix.Ix b,Data.Ix.Ix c,Data.Ix.Ix d,Data.Ix.Ix e,Data.Ix.Ix f) => Data.Ix.Ix (a,b,c,d,e,f);

{-# NEED #-}
instance Data.Ix @ (Data.Ix.Ix a,Data.Ix.Ix b,Data.Ix.Ix c,Data.Ix.Ix d,Data.Ix.Ix e,Data.Ix.Ix f,Data.Ix.Ix g) => Data.Ix.Ix (a,b,c,d,e,f,g);

{-# NEED #-}
instance Data.Ix @ (Data.Ix.Ix a,Data.Ix.Ix b,Data.Ix.Ix c,Data.Ix.Ix d,Data.Ix.Ix e,Data.Ix.Ix f,Data.Ix.Ix g,Data.Ix.Ix h) => Data.Ix.Ix (a,b,c,d,e,f,g,h);

{-# NEED #-}
instance Data.Ix @ (Data.Ix.Ix a,Data.Ix.Ix b,Data.Ix.Ix c,Data.Ix.Ix d,Data.Ix.Ix e,Data.Ix.Ix f,Data.Ix.Ix g,Data.Ix.Ix h,Data.Ix.Ix i) => Data.Ix.Ix (a,b,c,d,e,f,g,h,i);

{-# NEED #-}
instance Data.Ix @ (Data.Ix.Ix a,Data.Ix.Ix b,Data.Ix.Ix c,Data.Ix.Ix d,Data.Ix.Ix e,Data.Ix.Ix f,Data.Ix.Ix g,Data.Ix.Ix h,Data.Ix.Ix i,Data.Ix.Ix j) => Data.Ix.Ix (a,b,c,d,e,f,g,h,i,j);

{-# NEED #-}
instance Data.Ix @ (Data.Ix.Ix a,Data.Ix.Ix b,Data.Ix.Ix c,Data.Ix.Ix d,Data.Ix.Ix e,Data.Ix.Ix f,Data.Ix.Ix g,Data.Ix.Ix h,Data.Ix.Ix i,Data.Ix.Ix j,Data.Ix.Ix k) => Data.Ix.Ix (a,b,c,d,e,f,g,h,i,j,k);

{-# NEED #-}
instance Data.Ix @ (Data.Ix.Ix a,Data.Ix.Ix b,Data.Ix.Ix c,Data.Ix.Ix d,Data.Ix.Ix e,Data.Ix.Ix f,Data.Ix.Ix g,Data.Ix.Ix h,Data.Ix.Ix i,Data.Ix.Ix j,Data.Ix.Ix k,Data.Ix.Ix l) => Data.Ix.Ix (a,b,c,d,e,f,g,h,i,j,k,l);

{-# NEED #-}
instance Data.Ix @ (Data.Ix.Ix a,Data.Ix.Ix b,Data.Ix.Ix c,Data.Ix.Ix d,Data.Ix.Ix e,Data.Ix.Ix f,Data.Ix.Ix g,Data.Ix.Ix h,Data.Ix.Ix i,Data.Ix.Ix j,Data.Ix.Ix k,Data.Ix.Ix l,Data.Ix.Ix m) => Data.Ix.Ix (a,b,c,d,e,f,g,h,i,j,k,l,m);

{-# NEED #-}
instance Data.Ix @ (Data.Ix.Ix a,Data.Ix.Ix b,Data.Ix.Ix c,Data.Ix.Ix d,Data.Ix.Ix e,Data.Ix.Ix f,Data.Ix.Ix g,Data.Ix.Ix h,Data.Ix.Ix i,Data.Ix.Ix j,Data.Ix.Ix k,Data.Ix.Ix l,Data.Ix.Ix m,Data.Ix.Ix n) => Data.Ix.Ix (a,b,c,d,e,f,g,h,i,j,k,l,m,n);

{-# NEED #-}
instance Data.Ix @ (Data.Ix.Ix a,Data.Ix.Ix b,Data.Ix.Ix c,Data.Ix.Ix d,Data.Ix.Ix e,Data.Ix.Ix f,Data.Ix.Ix g,Data.Ix.Ix h,Data.Ix.Ix i,Data.Ix.Ix j,Data.Ix.Ix k,Data.Ix.Ix l,Data.Ix.Ix m,Data.Ix.Ix n,Data.Ix.Ix o) => Data.Ix.Ix (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o);

{-# NEED #-}
instance Data.Ix @ (Data.Ix.Ix a,Data.Ix.Ix b,Data.Ix.Ix c) => Data.Ix.Ix (a,b,c);

{-# NEED #-}
instance Data.Ix @ Data.Ix.Ix Ordering;

{-# NEED #-}
instance Data.Ix @ (Data.Ix.Ix a,Data.Ix.Ix b) => Data.Ix.Ix (a,b);

{-# NEED #-}
instance Data.Ix @ Data.Ix.Ix Char;

{-# NEED #-}
instance Data.Ix @ Data.Ix.Ix ();

{-# NEED #-}
instance System.IO @ Data.Ix.Ix System.IO.IOMode;

{-# NEED #-}
instance Prelude @ Ord Float;

{-# NEED #-}
instance Prelude @ Ord Double;

{-# NEED #-}
instance Prelude @ Ord Bool;

{-# NEED #-}
instance Prelude @ Ord Int;

{-# NEED #-}
instance Prelude @ Ord Integer;

{-# NEED #-}
instance Prelude @ (Ord a,Ord b,Ord c) => Ord (a,b,c);

{-# NEED #-}
instance Prelude @ Ord Ordering;

{-# NEED #-}
instance Prelude @ (Ord a,Ord b) => Ord (a,b);

{-# NEED #-}
instance Prelude @ (Ord a) => Ord [a];

{-# NEED #-}
instance Prelude @ (Ord a) => Ord (Maybe a);

{-# NEED #-}
instance Prelude @ Ord Char;

{-# NEED #-}
instance Prelude @ Ord ();

{-# NEED #-}
instance Prelude @ Eq Float;

{-# NEED #-}
instance Prelude @ Eq Double;

{-# NEED #-}
instance Prelude @ Eq Bool;

{-# NEED #-}
instance Prelude @ Eq Int;

{-# NEED #-}
instance Prelude @ Eq Integer;

{-# NEED #-}
instance Prelude @ (Eq a,Eq b,Eq c) => Eq (a,b,c);

{-# NEED #-}
instance Prelude @ Eq Ordering;

{-# NEED #-}
instance Prelude @ (Eq a,Eq b) => Eq (a,b);

{-# NEED #-}
instance Prelude @ (Eq a) => Eq [a];

{-# NEED #-}
instance Prelude @ (Eq a) => Eq (Maybe a);

{-# NEED #-}
instance Prelude @ Eq Char;

{-# NEED #-}
instance Prelude @ Eq ();

{-# NEED #-}
instance Prelude @ Functor Maybe;

{-# NEED #-}
instance Prelude @ Functor [];

interface Ix
{-# NEED #-}
class Ix a;
interface Data.Ix
{-# NEED Ix #-}
class (Ord a) => Ix a;
interface Prelude
{-# NEED #-}
interface System.IO
{-# NEED IOMode #-}
data IOMode;
interface ! Prelude
{-# NEED _enumRange #-}
_enumRange{-# 1 #-}::((a,a) -> [a]);

{-# NEED _enumInRange #-}
_enumInRange{-# 2 #-}::((a,a) -> (a -> Bool));

{-# NEED _enumIndex #-}
_enumIndex{-# 3 #-}::(String -> ((a,a) -> (a -> Int)));

{-# NEED _enumFromThen #-}
_enumFromThen{-# 3 #-}::(a -> (a -> (Int -> [a])));

{-# NEED _enumFromThenTo #-}
_enumFromThenTo{-# 3 #-}::(a -> (a -> (Int -> [a])));

{-# NEED _enumFromTo #-}
_enumFromTo{-# 2 #-}::(a -> (Int -> [a]));

{-# NEED _toEnum #-}
_toEnum{-# 1 #-}::(Int -> a);

{-# NEED _fromEnum #-}
_fromEnum{-# 1 #-}::(a -> Int);

{-# NEED _seq #-}
_seq{-# 2 #-}::(a -> (b -> b));

{-# NEED _blockedOnDeadMVar #-}
_blockedOnDeadMVar{-# 0 #-}::a

{-# NEED _deadlock #-}
_deadlock{-# 0 #-}::a

{-# NEED _divByZero #-}
_divByZero{-# 0 #-}::a

{-# NEED _noMethodError #-}
_noMethodError{-# 1 #-}::(String -> a)

{-# NEED _nonTermination #-}
_nonTermination{-# 0 #-}::a

{-# NEED _patternMatchFail #-}
_patternMatchFail{-# 1 #-}::(String -> a)

{-# NEED _recConError #-}
_recConError{-# 1 #-}::(String -> a)

{-# NEED _recSelError #-}
_recSelError{-# 1 #-}::(String -> a)

{-# NEED _recUpdError #-}
_recUpdError{-# 1 #-}::(String -> a)

{-# NEED uncurry #-}
uncurry{-# 2 #-}::((a -> (b -> c)) -> ((a,b) -> c));

{-# NEED curry #-}
curry{-# 3 #-}::(((a,b) -> c) -> (a -> (b -> c)));

{-# NEED until #-}
until{-# 3 #-}::((a -> Bool) -> ((a -> a) -> (a -> a)));

{-# NEED seq #-}
seq{-# 2 #-}::(a -> (b -> b));

{-# NEED (.) #-}
(.){-# 2 #-}::((a -> b) -> ((c -> a) -> (c -> b)));

{-# NEED lcm #-}
lcm{-# 2 #-}::(Integral a) => (a -> (a -> a));

{-# NEED gcd #-}
gcd{-# 2 #-}::(Integral a) => (a -> (a -> a));

{-# NEED asTypeOf #-}
asTypeOf{-# 0 #-}::(a -> (a -> a));

{-# NEED otherwise #-}
otherwise{-# 0 #-}::Bool;

{-# NEED const #-}
const{-# 2 #-}::(a -> (b -> a));

{-# NEED ($!) #-}
($!){-# 2 #-}::((a -> b) -> (a -> b));

{-# NEED ($) #-}
($){-# 2 #-}::((a -> b) -> (a -> b));

{-# NEED (=<<) #-}
(=<<){-# 2 #-}::(Monad b) => ((a -> (b c)) -> ((b a) -> (b c)));

{-# NEED sequence_ #-}
sequence_{-# 0 #-}::(Monad a) => ([(a b)] -> (a ()));

{-# NEED sequence #-}
sequence{-# 0 #-}::(Monad a) => ([(a b)] -> (a [b]));

{-# NEED mapM_ #-}
mapM_{-# 2 #-}::(Monad b) => ((a -> (b c)) -> ([a] -> (b ())));

{-# NEED mapM #-}
mapM{-# 2 #-}::(Monad b) => ((a -> (b c)) -> ([a] -> (b [c])));

{-# NEED reads #-}
reads{-# 0 #-}::(Read a) => (ReadS a);

{-# NEED readParen #-}
readParen{-# 2 #-}::(Bool -> ((ReadS a) -> (ReadS a)));

{-# NEED read #-}
read{-# 1 #-}::(Read a) => (String -> a);

{-# NEED lex #-}
lex{-# 1 #-}::(ReadS String);

{-# NEED shows #-}
shows{-# 0 #-}::(Show a) => (a -> ShowS);

{-# NEED showType #-}
showType{-# 1 #-}::(Show a) => (a -> String);

{-# NEED showChar #-}
showChar{-# 0 #-}::(Char -> ShowS);

{-# NEED showParen #-}
showParen{-# 2 #-}::(Bool -> (ShowS -> ShowS));

{-# NEED showString #-}
showString{-# 0 #-}::(String -> ShowS);

{-# NEED print #-}
print{-# 1 #-}::(Show a) => (a -> (YHC.Internal.IO ()));

{-# NEED subtract #-}
subtract{-# 0 #-}::(Num a) => (a -> (a -> a));

{-# NEED odd #-}
odd{-# 0 #-}::(Integral a) => (a -> Bool);

{-# NEED even #-}
even{-# 1 #-}::(Integral a) => (a -> Bool);

{-# NEED (^^) #-}
(^^){-# 2 #-}::(Fractional a,Integral b) => (a -> (b -> a));

{-# NEED (^) #-}
(^){-# 2 #-}::(Num a,Integral b) => (a -> (b -> a));

{-# NEED realToFrac #-}
realToFrac{-# 0 #-}::(Real a,Fractional b) => (a -> b);

{-# NEED numericEnumFromThenTo #-}
numericEnumFromThenTo{-# 3 #-}::(Fractional a,Ord a) => (a -> (a -> (a -> [a])));

{-# NEED numericEnumFromThen #-}
numericEnumFromThen{-# 2 #-}::(Fractional a) => (a -> (a -> [a]));

{-# NEED numericEnumFromTo #-}
numericEnumFromTo{-# 2 #-}::(Fractional a,Ord a) => (a -> (a -> [a]));

{-# NEED numericEnumFrom #-}
numericEnumFrom{-# 1 #-}::(Fractional a) => (a -> [a]);

{-# NEED fromIntegral #-}
fromIntegral{-# 0 #-}::(Integral a,Num b) => (a -> b);

{-# NEED catch #-}
catch{-# 2 #-}::((YHC.Internal.IO a) -> ((IOError -> (YHC.Internal.IO a)) -> (YHC.Internal.IO a)));

{-# NEED userError #-}
userError{-# 1 #-}::(String -> IOError);

{-# NEED ioError #-}
ioError{-# 1 #-}::(IOError -> (YHC.Internal.IO a));

{-# NEED writeFile #-}
writeFile{-# 2 #-}::(FilePath -> (String -> (YHC.Internal.IO ())));

{-# NEED readFile #-}
readFile{-# 1 #-}::(FilePath -> (YHC.Internal.IO String));

{-# NEED readLn #-}
readLn{-# 0 #-}::(Read a) => (YHC.Internal.IO a);

{-# NEED readIO #-}
readIO{-# 1 #-}::(Read a) => (String -> (YHC.Internal.IO a));

{-# NEED putStrLn #-}
putStrLn{-# 1 #-}::(String -> (YHC.Internal.IO ()));

{-# NEED putStr #-}
putStr{-# 0 #-}::(String -> (YHC.Internal.IO ()));

{-# NEED putChar #-}
putChar{-# 1 #-}::(Char -> (YHC.Internal.IO ()));

{-# NEED getChar #-}
getChar{-# 0 #-}::(YHC.Internal.IO Char);

{-# NEED getContents #-}
getContents{-# 0 #-}::(YHC.Internal.IO [Char]);

{-# NEED interact #-}
interact{-# 1 #-}::((String -> String) -> (YHC.Internal.IO ()));

{-# NEED getLine #-}
getLine{-# 0 #-}::(YHC.Internal.IO String);

{-# NEED appendFile #-}
appendFile{-# 2 #-}::(FilePath -> (String -> (YHC.Internal.IO ())));

{-# NEED _readFinal #-}
_readFinal{-# 2 #-}::(String -> ((a -> [(b,String)]) -> (a -> [(b,String)])));

{-# NEED _readField #-}
_readField{-# 3 #-}::(Read a) => (String -> (String -> ((String -> [((a -> b),String)]) -> (ReadS b))));

{-# NEED _readConInfix #-}
_readConInfix{-# 6 #-}::(Read a,Read b) => (Int -> (Int -> (Int -> (Int -> ((a -> (b -> c)) -> (String -> (ReadS c)))))));

{-# NEED _readConArg #-}
_readConArg{-# 1 #-}::(Read a) => ((String -> [((a -> b),String)]) -> (ReadS b));

{-# NEED _readCon0 #-}
_readCon0{-# 3 #-}::(Bool -> (a -> (String -> (ReadS a))));

{-# NEED _readCon #-}
_readCon{-# 2 #-}::(a -> (String -> (ReadS a)));

{-# NEED snd #-}
snd{-# 1 #-}::((a,b) -> b);

{-# NEED fst #-}
fst{-# 1 #-}::((a,b) -> a);

{-# NEED not #-}
not{-# 1 #-}::(Bool -> Bool);

{-# NEED (||) #-}
(||){-# 2 #-}::(Bool -> (Bool -> Bool));

{-# NEED (&&) #-}
(&&){-# 2 #-}::(Bool -> (Bool -> Bool));

{-# NEED zipWith3 #-}
zipWith3{-# 4 #-}::((a -> (b -> (c -> d))) -> ([a] -> ([b] -> ([c] -> [d]))));

{-# NEED zipWith #-}
zipWith{-# 3 #-}::((a -> (b -> c)) -> ([a] -> ([b] -> [c])));

{-# NEED zip3 #-}
zip3{-# 0 #-}::([a] -> ([b] -> ([c] -> [(a,b,c)])));

{-# NEED zip #-}
zip{-# 0 #-}::([a] -> ([b] -> [(a,b)]));

{-# NEED words #-}
words{-# 1 #-}::(String -> [String]);

{-# NEED unzip3 #-}
unzip3{-# 0 #-}::([(a,b,c)] -> ([a],[b],[c]));

{-# NEED unzip #-}
unzip{-# 0 #-}::([(a,b)] -> ([a],[b]));

{-# NEED unwords #-}
unwords{-# 1 #-}::([String] -> String);

{-# NEED unlines #-}
unlines{-# 0 #-}::([String] -> String);

{-# NEED takeWhile #-}
takeWhile{-# 2 #-}::((a -> Bool) -> ([a] -> [a]));

{-# NEED take #-}
take{-# 2 #-}::(Int -> ([a] -> [a]));

{-# NEED tail #-}
tail{-# 1 #-}::([a] -> [a]);

{-# NEED sum #-}
sum{-# 0 #-}::(Num a) => ([a] -> a);

{-# NEED splitAt #-}
splitAt{-# 2 #-}::(Int -> ([a] -> ([a],[a])));

{-# NEED span #-}
span{-# 2 #-}::((a -> Bool) -> ([a] -> ([a],[a])));

{-# NEED scanr1 #-}
scanr1{-# 2 #-}::((a -> (a -> a)) -> ([a] -> [a]));

{-# NEED scanr #-}
scanr{-# 3 #-}::((a -> (b -> b)) -> (b -> ([a] -> [b])));

{-# NEED scanl1 #-}
scanl1{-# 2 #-}::((a -> (a -> a)) -> ([a] -> [a]));

{-# NEED scanl #-}
scanl{-# 3 #-}::((a -> (b -> a)) -> (a -> ([b] -> [a])));

{-# NEED reverse #-}
reverse{-# 0 #-}::([a] -> [a]);

{-# NEED replicate #-}
replicate{-# 2 #-}::(Int -> (a -> [a]));

{-# NEED repeat #-}
repeat{-# 1 #-}::(a -> [a]);

{-# NEED product #-}
product{-# 0 #-}::(Num a) => ([a] -> a);

{-# NEED or #-}
or{-# 0 #-}::([Bool] -> Bool);

{-# NEED null #-}
null{-# 1 #-}::([a] -> Bool);

{-# NEED notElem #-}
notElem{-# 1 #-}::(Eq a) => (a -> ([a] -> Bool));

{-# NEED minimum #-}
minimum{-# 1 #-}::(Ord a) => ([a] -> a);

{-# NEED maximum #-}
maximum{-# 1 #-}::(Ord a) => ([a] -> a);

{-# NEED map #-}
map{-# 2 #-}::((a -> b) -> ([a] -> [b]));

{-# NEED lookup #-}
lookup{-# 2 #-}::(Eq a) => (a -> ([(a,b)] -> (Maybe b)));

{-# NEED lines #-}
lines{-# 1 #-}::(String -> [String]);

{-# NEED length #-}
length{-# 1 #-}::([a] -> Int);

{-# NEED last #-}
last{-# 1 #-}::([a] -> a);

{-# NEED iterate #-}
iterate{-# 2 #-}::((a -> a) -> (a -> [a]));

{-# NEED init #-}
init{-# 1 #-}::([a] -> [a]);

{-# NEED (!!) #-}
(!!){-# 2 #-}::([a] -> (Int -> a));

{-# NEED head #-}
head{-# 1 #-}::([a] -> a);

{-# NEED foldr1 #-}
foldr1{-# 2 #-}::((a -> (a -> a)) -> ([a] -> a));

{-# NEED foldr #-}
foldr{-# 3 #-}::((a -> (b -> b)) -> (b -> ([a] -> b)));

{-# NEED foldl1 #-}
foldl1{-# 2 #-}::((a -> (a -> a)) -> ([a] -> a));

{-# NEED foldl #-}
foldl{-# 3 #-}::((a -> (b -> a)) -> (a -> ([b] -> a)));

{-# NEED filter #-}
filter{-# 2 #-}::((a -> Bool) -> ([a] -> [a]));

{-# NEED elem #-}
elem{-# 1 #-}::(Eq a) => (a -> ([a] -> Bool));

{-# NEED dropWhile #-}
dropWhile{-# 2 #-}::((a -> Bool) -> ([a] -> [a]));

{-# NEED drop #-}
drop{-# 2 #-}::(Int -> ([a] -> [a]));

{-# NEED cycle #-}
cycle{-# 1 #-}::([a] -> [a]);

{-# NEED concatMap #-}
concatMap{-# 1 #-}::((a -> [b]) -> ([a] -> [b]));

{-# NEED concat #-}
concat{-# 0 #-}::([[a]] -> [a]);

{-# NEED break #-}
break{-# 1 #-}::((a -> Bool) -> ([a] -> ([a],[a])));

{-# NEED (++) #-}
(++){-# 2 #-}::([a] -> ([a] -> [a]));

{-# NEED any #-}
any{-# 1 #-}::((a -> Bool) -> ([a] -> Bool));

{-# NEED and #-}
and{-# 0 #-}::([Bool] -> Bool);

{-# NEED all #-}
all{-# 1 #-}::((a -> Bool) -> ([a] -> Bool));

{-# NEED either #-}
either{-# 3 #-}::((a -> b) -> ((c -> b) -> ((Either a c) -> b)));

{-# NEED maybe #-}
maybe{-# 3 #-}::(a -> ((b -> a) -> ((Maybe b) -> a)));

{-# NEED {(,,,,,,,,,,,,,,,,,,,) (,,,,,,,,,,,,,,,,,,,)} #-}
data (,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t
 = (,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t;

{-# NEED {(,,,,,,,,,,,,,,,,,,) (,,,,,,,,,,,,,,,,,,)} #-}
data (,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s
 = (,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s;

{-# NEED {(,,,,,,,,,,,,,,,,,) (,,,,,,,,,,,,,,,,,)} #-}
data (,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r
 = (,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r;

{-# NEED {(,,,,,,,,,,,,,,,,) (,,,,,,,,,,,,,,,,)} #-}
data (,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q
 = (,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q;

{-# NEED {(,,,,,,,,,,,,,,,) (,,,,,,,,,,,,,,,)} #-}
data (,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p
 = (,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p;

{-# NEED id #-}
id{-# 1 #-}::(a -> a);

{-# NEED undefined #-}
undefined{-# 0 #-}::a;

{-# NEED flip #-}
flip{-# 3 #-}::((a -> (b -> c)) -> (b -> (a -> c)));

{-# NEED _foldr #-}
_foldr{-# 3 #-}::((a -> (b -> b)) -> ([a] -> (b -> b)));

{-# NEED _filter #-}
_filter{-# 3 #-}::(Bool -> (([a] -> [a]) -> ([a] -> [a])));

{-# NEED error #-}
error{-# 1 #-}::(String -> a);
interface ! Data.Ratio
{-# NEED (%) #-}
(%){-# 2 #-}::(Prelude.Integral a) => (a -> (a -> (Data.Ratio.Ratio a)));
interface ! Prelude
{-# NEED Float #-}
data Float;

{-# NEED Double #-}
data Double;

{-# NEED {RealFloat exponent significand scaleFloat atan2 floatRadix floatDigits floatRange decodeFloat encodeFloat isNaN isInfinite isDenormalized isNegativeZero isIEEE} #-}
class (RealFrac a,Floating a) => RealFloat a where {
  exponent{-# 1 #-}::(a -> Int);
  significand{-# 1 #-}::(a -> a);
  scaleFloat{-# 2 #-}::(Int -> (a -> a));
  atan2{-# 2 #-}::(a -> (a -> a));
  floatRadix{-# 1 #-}::(a -> Integer);
  floatDigits{-# 1 #-}::(a -> Int);
  floatRange{-# 1 #-}::(a -> (Int,Int));
  decodeFloat{-# 1 #-}::(a -> (Integer,Int));
  encodeFloat{-# 2 #-}::(Integer -> (Int -> a));
  isNaN{-# 1 #-}::(a -> Bool);
  isInfinite{-# 1 #-}::(a -> Bool);
  isDenormalized{-# 1 #-}::(a -> Bool);
  isNegativeZero{-# 1 #-}::(a -> Bool);
  isIEEE{-# 1 #-}::(a -> Bool);
};

{-# NEED {Floating (**) logBase sqrt tan tanh pi exp log sin cos asin acos atan sinh cosh asinh acosh atanh} #-}
class (Fractional a) => Floating a where {
  (**){-# 2 #-}::(a -> (a -> a));
  logBase{-# 2 #-}::(a -> (a -> a));
  sqrt{-# 1 #-}::(a -> a);
  tan{-# 1 #-}::(a -> a);
  tanh{-# 1 #-}::(a -> a);
  pi{-# 0 #-}::a;
  exp{-# 1 #-}::(a -> a);
  log{-# 1 #-}::(a -> a);
  sin{-# 1 #-}::(a -> a);
  cos{-# 1 #-}::(a -> a);
  asin{-# 1 #-}::(a -> a);
  acos{-# 1 #-}::(a -> a);
  atan{-# 1 #-}::(a -> a);
  sinh{-# 1 #-}::(a -> a);
  cosh{-# 1 #-}::(a -> a);
  asinh{-# 1 #-}::(a -> a);
  acosh{-# 1 #-}::(a -> a);
  atanh{-# 1 #-}::(a -> a);
};

{-# NEED {RealFrac truncate round ceiling floor properFraction} #-}
class (Real a,Fractional a) => RealFrac a where {
  truncate{-# 1 #-}::(Integral b) => (a -> b);
  round{-# 1 #-}::(Integral b) => (a -> b);
  ceiling{-# 1 #-}::(Integral b) => (a -> b);
  floor{-# 1 #-}::(Integral b) => (a -> b);
  properFraction{-# 1 #-}::(Integral b) => (a -> (b,a));
};

{-# NEED {Fractional recip (/) fromRational} #-}
class (Num a) => Fractional a where {
  recip{-# 1 #-}::(a -> a);
  (/){-# 2 #-}::(a -> (a -> a));
  fromRational{-# 1 #-}::(Data.Ratio.Rational -> a);
};

{-# NEED {Integral quot rem div mod quotRem divMod toInteger} Data.Ratio.Ratio {Real toRational} Data.Ratio.Rational #-}
class (Real a,Enum a) => Integral a where {
  quot{-# 2 #-}::(a -> (a -> a));
  rem{-# 2 #-}::(a -> (a -> a));
  div{-# 2 #-}::(a -> (a -> a));
  mod{-# 2 #-}::(a -> (a -> a));
  quotRem{-# 2 #-}::(a -> (a -> (a,a)));
  divMod{-# 2 #-}::(a -> (a -> (a,a)));
  toInteger{-# 1 #-}::(a -> Integer);
};
data (Integral a) => Data.Ratio.Ratio a;
class (Num a,Ord a) => Real a where {
  toRational{-# 1 #-}::(a -> Data.Ratio.Rational);
};
type {-# 1 #-} Data.Ratio.Rational = (Data.Ratio.Ratio Integer);

{-# NEED {Num (-) negate (+) (*) abs signum fromInteger} #-}
class (Eq a,Show a) => Num a where {
  (-){-# 2 #-}::(a -> (a -> a));
  negate{-# 1 #-}::(a -> a);
  (+){-# 2 #-}::(a -> (a -> a));
  (*){-# 2 #-}::(a -> (a -> a));
  abs{-# 1 #-}::(a -> a);
  signum{-# 1 #-}::(a -> a);
  fromInteger{-# 1 #-}::(Integer -> a);
};

{-# NEED Integer #-}
data Integer;

{-# NEED {(,,,) (,,,)} #-}
data (,,,) a b c d
 = (,,,) a b c d;

{-# NEED {(,,,,) (,,,,)} #-}
data (,,,,) a b c d e
 = (,,,,) a b c d e;

{-# NEED {(,,,,,) (,,,,,)} #-}
data (,,,,,) a b c d e f
 = (,,,,,) a b c d e f;

{-# NEED {(,,,,,,) (,,,,,,)} #-}
data (,,,,,,) a b c d e f g
 = (,,,,,,) a b c d e f g;

{-# NEED {(,,,,,,,) (,,,,,,,)} #-}
data (,,,,,,,) a b c d e f g h
 = (,,,,,,,) a b c d e f g h;

{-# NEED {(,,,,,,,,) (,,,,,,,,)} #-}
data (,,,,,,,,) a b c d e f g h i
 = (,,,,,,,,) a b c d e f g h i;

{-# NEED {(,,,,,,,,,) (,,,,,,,,,)} #-}
data (,,,,,,,,,) a b c d e f g h i j
 = (,,,,,,,,,) a b c d e f g h i j;

{-# NEED {(,,,,,,,,,,) (,,,,,,,,,,)} #-}
data (,,,,,,,,,,) a b c d e f g h i j k
 = (,,,,,,,,,,) a b c d e f g h i j k;

{-# NEED {(,,,,,,,,,,,) (,,,,,,,,,,,)} #-}
data (,,,,,,,,,,,) a b c d e f g h i j k l
 = (,,,,,,,,,,,) a b c d e f g h i j k l;

{-# NEED {(,,,,,,,,,,,,) (,,,,,,,,,,,,)} #-}
data (,,,,,,,,,,,,) a b c d e f g h i j k l m
 = (,,,,,,,,,,,,) a b c d e f g h i j k l m;

{-# NEED {(,,,,,,,,,,,,,) (,,,,,,,,,,,,,)} #-}
data (,,,,,,,,,,,,,) a b c d e f g h i j k l m n
 = (,,,,,,,,,,,,,) a b c d e f g h i j k l m n;

{-# NEED {(,,,,,,,,,,,,,,) (,,,,,,,,,,,,,,)} #-}
data (,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o
 = (,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o;

{-# NEED {(,,) (,,)} #-}
data (,,) a b c
 = (,,) a b c;

{-# NEED {Functor fmap} #-}
class Functor a where {
  fmap{-# 2 #-}::((b -> c) -> ((a b) -> (a c)));
};

{-# NEED {Monad (>>) fail (>>=) return} #-}
class Monad a where {
  (>>){-# 2 #-}::((a b) -> ((a c) -> (a c)));
  fail{-# 1 #-}::(String -> (a b));
  (>>=){-# 2 #-}::((a b) -> ((b -> (a c)) -> (a c)));
  return{-# 1 #-}::(b -> (a b));
};

{-# NEED {Bounded minBound maxBound} #-}
class Bounded a where {
  minBound{-# 0 #-}::a;
  maxBound{-# 0 #-}::a;
};

{-# NEED {Read readList readsPrec} #-}
class Read a where {
  readList{-# 0 #-}::(ReadS [a]);
  readsPrec{-# 1 #-}::(Int -> (ReadS a));
};

{-# NEED ReadS #-}
type {-# 4 #-} ReadS a = (String -> [(a,String)]);

{-# NEED {(,) (,)} #-}
data (,) a b
 = (,) a b;

{-# NEED {Enum succ pred enumFromTo enumFromThenTo toEnum fromEnum enumFrom enumFromThen} #-}
class Enum a where {
  succ{-# 1 #-}::(a -> a);
  pred{-# 1 #-}::(a -> a);
  enumFromTo{-# 2 #-}::(a -> (a -> [a]));
  enumFromThenTo{-# 3 #-}::(a -> (a -> (a -> [a])));
  toEnum{-# 1 #-}::(Int -> a);
  fromEnum{-# 1 #-}::(a -> Int);
  enumFrom{-# 1 #-}::(a -> [a]);
  enumFromThen{-# 2 #-}::(a -> (a -> [a]));
};

{-# NEED {Show showsPrec show showList showsType} #-}
class Show a where {
  showsPrec{-# 2 #-}::(Int -> (a -> ShowS));
  show{-# 1 #-}::(a -> String);
  showList{-# 1 #-}::([a] -> ShowS);
  showsType{-# 1 #-}::(a -> ShowS);
};

{-# NEED ShowS #-}
type {-# 3 #-} ShowS = (String -> String);

{-# NEED Int #-}
data Int;

{-# NEED {Ord compare (<=) (<) (>=) (>) max min} #-}
class (Eq a) => Ord a where {
  compare{-# 2 #-}::(a -> (a -> Ordering));
  (<=){-# 2 #-}::(a -> (a -> Bool));
  (<){-# 2 #-}::(a -> (a -> Bool));
  (>=){-# 2 #-}::(a -> (a -> Bool));
  (>){-# 2 #-}::(a -> (a -> Bool));
  max{-# 2 #-}::(a -> (a -> a));
  min{-# 2 #-}::(a -> (a -> a));
};

{-# NEED {Ordering LT EQ GT} #-}
data Ordering
  = LT
  | EQ
  | GT ;
interface ! YHC.Internal
{-# NEED {IO IO} #-}
newtype {-#  #-} IO a
  = IO (YHC.Internal.World -> (Either IOError a));
interface ! Prelude
{-# NEED {IOError IOError EOFError PatternError UserError} #-}
data IOError
  = IOError String (Maybe String) (Maybe YHC.Primitive.Handle) YHC.ErrNo.ErrNo
  | EOFError String YHC.Primitive.Handle
  | PatternError String
  | UserError String String;
interface YHC.ErrNo
{-# NEED ErrNo #-}
data ErrNo;
interface System.IO
{-# NEED Handle #-}
newtype {-#  #-} Handle;
interface ! Prelude
{-# NEED {() ()} #-}
data ()
 = ();
interface Foreign.ForeignPtr
{-# NEED ForeignPtr #-}
data ForeignPtr a;
interface ! Prelude
{-# NEED {Maybe Nothing Just} #-}
data Maybe a
  = Nothing
  | Just a;

{-# NEED {Either Left Right} #-}
data Either a b
  = Left a
  | Right b;
interface YHC.Internal
{-# NEED World #-}
data World;
interface ! Prelude
{-# NEED FilePath #-}
type {-# 2 #-} FilePath = String;

{-# NEED String #-}
type {-# 1 #-} String = [Char];

{-# NEED Char #-}
data Char;

{-# NEED {[] [] (:)} #-}
data [] a
  = []
  | (:) a [a];

{-# NEED {Eq (/=) (==)} #-}
class Eq a where {
  (/=){-# 2 #-}::(a -> (a -> Bool));
  (==){-# 2 #-}::(a -> (a -> Bool));
};

{-# NEED {Bool True False} #-}
data Bool
  = True
  | False ;

{-# NEED (->) #-}
data (->) a b;
}

