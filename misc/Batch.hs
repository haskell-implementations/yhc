
module Main(main) where

import System
import Char
import List
import Maybe


main = do x <- getArgs
          if null x
            then defaultTranslate
            else mapM_ translate x
          putStrLn "done"


translate :: FilePath -> IO ()
translate x = do src <- readFile x
                 writeFile (x ++ ".bat") (convert src)
                 

defaultTranslate :: IO ()
defaultTranslate = do src <- readFile "Makefile.bpp"
                      writeFile ("../Makefile.bat") (convert src)
                 

type Cond = String
type Var = String

data Stmt = Proc String [String] [Stmt]
          | If [(Cond, [Stmt])]
          | While Cond [Stmt]
          | Kill
          | Call String String [String]
          | Return String
          | Add Var String
          | Other String
          deriving Show


convert :: String -> String
convert x = showStmts $ readStmts $ filter (not . isBlank) $ map trimLeft $ lines x


---------------------------------------------------------------------
-- PARSER

trimLeft x = dropWhile isSpace x

isBlank ('-':'-':_) = True
isBlank "" = True
isBlank _ = False


readStmts :: [String] -> [Stmt]
readStmts [] = []
readStmts ys = x : readStmts xs
    where (x, xs) = readStmt ys


readStmtsWhile :: String -> [String] -> ([Stmt], [String])
readStmtsWhile stop (x:xs) | wordHead x == stop = ([], xs)
                           | otherwise = let (a,b) = readStmt (x:xs)
                                             (c,d) = readStmtsWhile stop b
                                         in (a:c, d)
readStmtsWhile stop [] = error $ "End of file, while waiting for a " ++ stop


multiline = [("PROCEDURE", readProc), ("IF", readIf), ("WHILE", readWhile)]
singleline = [("ADD", readAdd), ("CALL", readCall), ("EVAL", readEval), ("KILL", readKill), ("RETURN", readReturn)]
futureline = ["ELSE","ELIF"]


wordHead x = takeWhile (not . isSpace) x
wordTail x = dropWhile isSpace $ dropWhile (not . isSpace) x


readStmt :: [String] -> (Stmt, [String])
readStmt (x:xs) | isJust whM =
    let Just gen = whM
        (done, todo) = readStmtsWhile ("END_" ++ wh) xs
    in (gen wt done, todo)

                | isJust whS = (fromJust whS wt, xs)
                | not (wh `elem` futureline) && not (null wh) && all isUpper wh = error $ "Unrecognised keyword, " ++ wh
                | otherwise  = (Other x, xs)
    where
        wh = wordHead x
        wt = wordTail x
        whM = lookup wh multiline
        whS = lookup wh singleline


readProc :: String -> [Stmt] -> Stmt
readProc x y = Proc name args y
    where (name:args) = words x


readWhile :: String -> [Stmt] -> Stmt
readWhile x y = While x y


readIf :: String -> [Stmt] -> Stmt
readIf cond body = If $ f cond [] body
    where
        f cond done [] = [(cond, reverse done)]
        f cond done (Other t:odo)
            | wh == "ELSE" = (cond, reverse done) : f "1==1" [] odo
            | wh == "ELIF" = (cond, reverse done) : f (wordTail t) [] odo
            where wh = wordHead t
        f cond done (t:odo) = f cond (t:done) odo


readAdd :: String -> Stmt
readAdd x = Add x ""

readCall :: String -> Stmt
readCall x = Call "" name args
    where (name:args) = words x

readEval :: String -> Stmt
readEval x = Call res name args
    where (res:name:args) = words x

readKill :: String -> Stmt
readKill x = Kill

readReturn :: String -> Stmt
readReturn x = Return x

---------------------------------------------------------------------
-- CODE GEN

type Ctxt = [Int]

showCtxt x = "INTERNAL_" ++ (concat $ intersperse "_" $ map show x)
moreCtxt x = [i:x | i <- [1..]]
newCtxt  x = (1:x)

prefix =
    ["@ECHO OFF"
    ,"REM Automatically Generated, do not modify"
    ,"REM Generated by Batch++, (C) Neil Mitchell 2006"
    ,"REM Part of Yhc, suggestion by Tom Shackell"
    ,""
    ,"set INTERNAL_CALL=call %0 INTERNAL_SWITCH " ++ procName ""
    ,"if not \"%1\" == \"INTERNAL_SWITCH\" goto INTERNAL_MAIN"
    ,"shift"
    ,"shift"
    ,"goto %0"
    ,":INTERNAL_MAIN"
    ,"set INTERNAL_ABORT=0"
    ,"goto " ++ procName "Main"
    ,""]

suffix =
    [""
    ,":INTERNAL_EXIT"
    ,""]


showStmts :: [Stmt] -> String
showStmts xs = unlines $ prefix ++ showStmtsCtxt [] xs ++ suffix


showStmtsCtxt :: Ctxt -> [Stmt] -> [String]
showStmtsCtxt ctxt stmts = concat $ zipWith showStmtCtxt (moreCtxt ctxt) stmts


showStmtCtxt :: Ctxt -> Stmt -> [String]
showStmtCtxt ctxt (Other x) = [x]

showStmtCtxt ctxt (Kill) = ["set INTERNAL_ABORT=1", "goto INTERNAL_EXIT"]

showStmtCtxt ctxt (Call res x args) =
    ["%INTERNAL_CALL%" ++ x ++ concatMap (' ':) args,
    "if \"%INTERNAL_ABORT%\" == \"1\" goto INTERNAL_EXIT"] ++
    (if null res then [] else ["set " ++ res ++ "=%INTERNAL_RETURN%"])

showStmtCtxt ctxt (Proc name args body) =
        ["", ":" ++ procName name, "set INTERNAL_RETURN="] ++
        zipWith f [1..] args ++
        showStmtsCtxt (newCtxt ctxt) body ++
        ["goto INTERNAL_EXIT", ""]
    where
        f n x = "set " ++ x ++ "=%" ++ show n

showStmtCtxt ctxt (Return x) =
    ["set INTERNAL_RETURN=" ++ x, "goto INTERNAL_EXIT"]

showStmtCtxt ctxt (If opts) =
        concat (zipWith test lbls (map fst opts)) ++
        ["goto " ++ lbl] ++
        concat (zipWith code lbls (map snd opts)) ++
        [":" ++ lbl]
    where
        lbl = showCtxt ctxt
        lbls = moreCtxt ctxt
        
        test c cond = ["if " ++ cond ++ " goto " ++ showCtxt c]
        code c body = [":" ++ showCtxt c] ++ showStmtsCtxt (1:c) body ++ ["goto " ++ lbl]

showStmtCtxt ctxt (While cond stmts) =
        [":" ++ top, "if " ++ cond ++ " goto " ++ begin, "goto " ++ bot, ":" ++ begin] ++
        showStmtsCtxt inside stmts ++
        ["goto " ++ top, ":" ++ bot]
    where
        (mine:inside:_) = moreCtxt ctxt
        (top:bot:begin:_) = map showCtxt (moreCtxt mine)

        
showStmtCtxt ctxt x = error $ "Unhandled, " ++ show x


procName x = "INTERNAL_PROCEDURE_" ++ x
